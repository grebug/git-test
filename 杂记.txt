effective java：p23

主机名	l-kola[1-8].f.dev.cn0
主机名	l-flight[1-8].wap.dev.cn0
KEY PASSPHRASE	>ku7:6zi?q=,?>0

l-kola2.f.dev.cn0

jdk 1.7  java开发/运行环境
maven  java 依赖管理 编译等
idea  java ide
git  代码仓库
SecureCRT   window系统登陆开发机

qtalk  公司内部通讯
邮箱   公司内部通讯
开发机权限  http://ops.corp.qunar.com/ops/account/  l-flight[1-8].wap.dev.cn0 l-kola[1-8].f.dev.cn0  sudo权限
gitlab   http://gitlab.corp.qunar.com/



git clone http://gitlab.corp.qunar.com/flightuser/incarnation.git
git branch -r
git checkout 20170622_init
git status
git checkout origin/master




git clone [url]
会默认创建一个远程仓库origin
git add
git status
git diff
git commit
git branch
git branch -D   删除本地分支
git log

git checkout -b 123 origin/master
新建的123与origin/master默认就有关联(--setupstream)!

git push  origin  :123
可以用于删除远程仓库origin的分支123

git push origin 123 --set-upstream
设置本地与远程仓库中分支的关联

git fetch origin
git reset --hard origin/master
丢弃本地所有改动与提交

git branch -vv（两个v），就能够看到本地分支跟踪的远程分支。

git branch --set-upstream master origin/next


mvn compile	编译源码
mvn test	执行test
mvn test-compile	编译测试代码，test可执行
mvn package	项目打包
mvn install	把project安装到本地的repository中，可作为本地其他项目的依赖
mvn site	为你的project创建一个站点
mvn clean	清除target目录下的所有文件
mvn eclipse:eclipse	为project生成eclipse的工程文件和classpath文件
mvn idea:idea	生成idea项目

mvn archetype:generate	创建mvn项目 
mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app	创建mvn项目
mvn jetty:run            运行项目于jetty上 
mvn -Dwtpversion=1.0 eclipse:eclipse        生成Wtp插件的Web项目 
mvn -Dwtpversion=1.0 eclipse:clean          清除Eclipse项目的配置信息(Web项目) 

组合使用goal命令，如只打包不测试：mvn -Dtest package
只打jar包：mvn jar:jar
只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile
清除eclipse的一些系统设置：mvn eclipse:clean

maven内置三种生命周期：default, clean 和 site。

default生命周期：
validate：validate the project is correct and all necessary information is available.
initialize：initialize build state, e.g. set properties or create directories.
generate-sources：generate any source code for inclusion in compilation.
process-sources：process the source code, for example to filter any values.
generate-resources：generate resources for inclusion in the package.
process-resources：copy and process the resources into the destination directory, ready for packaging.
compile：compile the source code of the project.
process-classes：post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.
generate-test-sources：generate any test source code for inclusion in compilation.
process-test-sources：process the test source code, for example to filter any values.
generate-test-resources：create resources for testing.
process-test-resources：copy and process the resources into the test destination directory.
test-compile：compile the test source code into the test destination directory
process-test-classes：post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above.
test：run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.
prepare-package：perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above)
package：take the compiled code and package it in its distributable format, such as a JAR.
pre-integration-test：perform actions required before integration tests are executed. This may involve things such as setting up the required environment.
integration-test：process and deploy the package if necessary into an environment where integration tests can be run.
post-integration-test：perform actions required after integration tests have been executed. This may including cleaning up the environment.
verify：run any checks to verify the package is valid and meets quality criteria.
install：install the package into the local repository, for use as a dependency in other projects locally.
deploy：done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.





Tomcat服务器的启动是基于一个server.xml文件的，Tomcat启动的时候首先会启动一个Server，Server里面就会启动Service，Service里面就会启动多个"Connector(连接器)"，每一个连接器都在等待客户机的连接，当有用户使用浏览器去访问服务器上面的web资源时，首先是连接到Connector(连接器)，Connector(连接器)是不处理用户的请求的，而是将用户的请求交给一个Engine(引擎)去处理，Engine(引擎)接收到请求后就会解析用户想要访问的Host，然后将请求交给相应的Host，Host收到请求后就会解析出用户想要访问这个Host下面的哪一个Web应用,一个web应用对应一个Context。



			Spring
控制反转，我们可以把它看作是一个概念。而依赖注入(Dependency Injection)是控制反转的一种实现方法。James Shore给出了依赖注入的定义：依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。
setter注入(setter injection)和构造器注入(constructor injection)。


泛型注入？


Spring IoC容器：
BeanFactory（资源缺乏的移动设备时）和ApplicationContext（较高级目前常用,BeanFactory的派生类）
两个接口各自的实现类：
BeanFactory：XmlBeanFactory
ApplicationContext：FileSystemXmlApplicationContext，ClassPathXmlApplicationContext，WebXmlApplicationContext

xml配置文件基础内容：
<bean id="helloWorld" class="com.spring.HelloWorld">
        <property name="message" value="Hello World!"/>
</bean>

Bean的作用域：（scope=）
singleton，prototype，request，session，globalSession

一般说来，有状态的 bean 使用 prototype 作用域和没有状态的 bean 使用 singleton 作用域。

Bean后置处理器：BeanPostProcessor
实现该接口，包含两个方法，分别于实例化前后被回调。


依赖注入的一个实例：
从 TextEditor 中删除了全面控制，并且把它保存到其他地方（即 XML 配置文件），且依赖关系（即 SpellChecker 类）通过类构造函数被注入到 TextEditor 类中。因此，控制流通过依赖注入（DI）已经“反转”，因为你已经有效地委托依赖关系到一些外部系统。



@RequestMapping(value = "/student", method = RequestMethod.GET)
   public ModelAndView student() {
      return new ModelAndView("student", "command", new Student());
   }
第一个 service 方法 student()，我们已经在名称为 “command” 的 ModelAndView 对象中传递一个空的 Student 对象，因为 spring 框架需要一个名称的 “command” 的对象，如果你在 JSP 文件中使用 <form:form> 标签。所以，当 student() 方法被调用时，它返回 student.jsp 视图。







			Spring注解
@Autowired，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。
@Autowired
@Qualifier("personDaoBean") 存在多个实例配合使用（指定注入Bean的名称）

@Resource的装配顺序：
(1)、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配
(2)、指定了name或者type则根据指定的类型去匹配bean
(3)、指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错

然后，区分一下@Autowired和@Resource两个注解的区别：
(1)、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配
(2)、@Autowired是Spring的注解，@Resource是J2EE的注解，Spring属于第三方的，J2EE是Java自己的东西，因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。

@Service注解对应的是业务层Bean，其实做了两件事情：
(1)、声明Zoo.java是一个bean，这点很重要，因为Zoo.java是一个bean，其他的类才可以使用@Autowired将Zoo作为一个成员变量自动注入。
(2)、Zoo.java在bean中的id是"zoo"，即类名且首字母小写。

@Component是所有受Spring 管理组件的通用形式，@Component注解可以放在类的头上，@Component不推荐使用。

@Controller对应控制层(表现层)的Bean，也就是Action。如果@Controller不指定其value【@Controller】，则默认的bean名字为这个类的类名首字母小写，如果指定value【@Controller(value="UserAction")】或者【@Controller("UserAction")】，则使用value作为bean的名字。

可以利用容器的scope="prototype"来保证每一个请求有一个单独的Action来处理，避免struts中Action的线程安全问题。spring 默认scope 是单例模式(scope="singleton")，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2 是要求每次次访问都对应不同的Action，scope="prototype" 可以保证当有请求的时候都创建一个Action对象。

@Repository对应数据访问层Bean，即DAO。

使用注解之前要开启自动扫描功能
<context:component-scan base-package="cn.test"/> 

@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。
@Lazy(true) 表示延迟初始化
@Scope用于指定scope作用域的（用在类上）
@PostConstruct用于指定初始化方法（用在方法上）
@PreDestory用于指定销毁方法（用在方法上）
@DependsOn：定义Bean初始化及销毁时的顺序
@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常
@Async异步方法调用
@Transactional( rollbackFor={Exception.class}) 事务管理







        SpringMVC注解
@RequestMapping(value="/content",method="RequestMethod.GET",params="action=del",headers="Accept=application/json",consumes="application/json",produces="application/json")
属性params要求请求的URL中参数必须包含指定内容
属性headers要求请求头中必须包含指定参数
属性consumes指定处理请求的提交内容类型(Content-Type)
属性produces指定返回的内容类型(Accept)

@RequestParam用于将请求参数区数据映射到功能处理方法的参数上。
三个属性：value,required,defaultValue
public String requestparam4(@RequestParam(value="username",required=false) String username)

@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。
@RequestMapping(value="/users/{userId}/topics/{topicId}")
public String test(@PathVariable(value="userId") int userId, @PathVariable(value="topicId") int topicId) 

@ModelAttribute可以应用在方法参数上或方法上。他的作用主要是当注解在方法参数上时会将注解的参数对象添加到Model中；当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，用于填充model属性，实际上控制器中的@ModelAttribute方法是在同一控制器中的所有@RequestMapping方法被调用之前调用的。
两种类型的@ModelAttribute方法。一种是：只加入一个属性，用方法的返回类型隐含表示(属性名称默认为返回类型首字母小写，亦可通过@ModelAttribute的value属性自定义)。另一种是：方法接受一个Model类型的参数，这个model可以加入任意多个model属性。
@Controller
@RequestMapping(value="/test")
public class TestController {
    @ModelAttribute//1
    public void populateModel(@RequestParam String abc, Model model) {
        model.addAttribute("attributeName", abc);
    }
    
    @RequestMapping(value = "/helloWorld")
    public String helloWorld() {
       return "test/helloWorld";
    }
}

@ModelAttribute//2
public User getUserInfo(String id){
    if(id!=null && !id.equals("")){
        return userService.getUserInfo(id);
    }
    return null;
}

@ModelAttribute和@RequestMapping可同时注释一个方法，这时这个方法的返回值并不是表示一个视图名称，而是model属性的值，视图名称由RequestToViewNameTranslator根据请求"/helloWorld"转换为helloWorld。


当@ModelAttribute注解用于方法参数时，它有了双重功能，即“存/取”。首先，它从模型中取出数据并赋予对应的参数，如果模型中尚不存在，则实例化一个，并存放于模型中；其次，一旦模型中已存在此数据对象，接下来一个很重要的步骤便是将请求参数或提交的表单绑定到此对象上（请求参数名映射对象属性名），这是Spring MVC提供的一个非常便利的机制--数据绑定。



类定义处标注@SessionAttributes：
可以使用两个属性types和value来指定要session化的ModelMap属性。
ModelMap中的属性默认的作用域是request级别。
@SessionAttributes("currUser")
将ModelMap中属性名为currUser的属性放到Session属性列表中，以便这个属性可以跨请求访问，在controller内部共享 model 属性。
@SessionAttributes需要清除时，使用SessionStatus.setComplete();来清除。



@Responsebody表示该方法的返回结果直接写入HTTP response body中。一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@Responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。
@RequestBody将HTTP请求正文插入方法中,使用适合的HttpMessageConverter将请求体写入某个对象。

@RequestBody 将HTTP请求正文转换为适合的HttpMessageConverter对象。
@ResponseBody 将内容或对象作为 HTTP 响应正文返回，并调用适合HttpMessageConverter的Adapter转换对象，写入输出流。

@RequestBody作用： 
 i) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；
 ii) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。
使用时机：
A) GET、POST方式提时， 根据request header Content-Type的值来判断:
application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）；
multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；
其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；
B) PUT方式提交时， 根据request header Content-Type的值来判断:
application/x-www-form-urlencoded， 必须；
multipart/form-data, 不能处理；
其他格式， 必须；
说明：request的body部分的数据编码格式由header部分的Content-Type指定；

@ResponseBody
作用：
	该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。
使用时机：
	返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；




		SpringMVC常用配置
web.xml:
配置前段控制器DispatcherServlet
<servlet>  
    <servlet-name>springMVC</servlet-name>  
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  
    <init-param>  
        <param-name>contextConfigLocation</param-name>  
        <param-value>classpath:/springMVC.xml</param-value>  
    </init-param>  
    <load-on-startup>1</load-on-startup>  
</servlet>  
<servlet-mapping>  
    <servlet-name>springMVC</servlet-name>  
    <url-pattern>/</url-pattern>  
</servlet-mapping>

配置监听器，一般在Struts项目中会使用，SpringMVC一般不使用listener监听器来加载spring的配置文件，只使用DispatcherServlet来加载Spring的配置
<listener>   
  <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>   
</listener>


SpringMVC.xml：
	<!-- 自动扫描的包名 -->  
    <context:component-scan base-package="com.app,com.core,JUnit4" ></context:component-scan>  
      
    <!-- 默认的注解映射的支持，会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter 两个bean,是spring MVC为@Controllers分发请求所必须的。并提供了：数据绑定支持，@NumberFormatannotation支持，@DateTimeFormat支持，@Valid支持，读写XML的支持（JAXB），读写JSON的支持（Jackson）。 -->

    <mvc:annotation-driven />  


    <!-- 视图解释类 -->  
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">  
        <property name="prefix" value="/WEB-INF/jsp/"/>  
        <property name="suffix" value=".jsp"/><!--可为空,方便实现自已的依据扩展名来选择视图解释类的逻辑  -->  
        <property name="viewClass" value="org.springframework.web.servlet.view.JstlView" />  
    </bean>  

    <!-- 拦截器：HandlerInterceptor接口，HandlerInterceptorAdapter适配器，实现这个接口或继承此类，可以非常方便的实现自己的拦截器。preHandle,postHandle,afterCompletion三个方法分别实现预处理、后处理（调用了Service并返回ModelAndView，但未进行页面渲染）、返回处理（已经渲染了页面）。
    Spring MVC的拦截器，是属于HandlerMapping级别的，可以有多个HandlerMapping ，每个HandlerMapping可以有自己的拦截器。一个请求交给一个HandlerMapping时，这个HandlerMapping先找有没有处理器来处理这个请求，如果找到了，就执行拦截器，执行完拦截后，交给目标处理器。如果没有找到处理器，那么这个拦截器就不会被执行。  -->  
    <mvc:interceptors>
        <bean class="com.core.mvc.MyInteceptor"/>
    </mvc:interceptors>


    <!-- 如果你的DispatcherServlet拦截"*.do"这样的有后缀的URL，就不存在访问不到静态资源的问题。如果你的DispatcherServlet拦截"/"，为了实现REST风格，拦截了所有的请求，那么同时对*.js,*.jpg等静态文件的访问也就被拦截了。
    对静态资源文件的访问：使用默认的Servlet来响应静态文件。把"/**" url,注册到SimpleUrlHandlerMapping的urlMap中,把对静态资源的访问由HandlerMapping转到org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler处理并返回.DefaultServletHttpRequestHandhandlerler使用就是各个Servlet容器自己的默认Servlet.  方案一 -->
    
    <mvc:default-servlet-/>    


    <!-- 对静态资源文件的访问：把mapping的URI注册到SimpleUrlHandlerMapping的urlMap中,key为mapping的URI pattern值,而value为ResourceHttpRequestHandler。由ResourceHttpRequestHandler进行处理静态资源的映射访问及返回。  方案二 -->  
    <mvc:resources mapping="/images/**" location="/images/" cache-period="31556926"/>  
    <mvc:resources mapping="/js/**" location="/js/" cache-period="31556926"/>  
    <mvc:resources mapping="/css/**" location="/css/" cache-period="31556926"/> 

    <!-- 要写在DispatcherServlet的前面，让defaultServlet先拦截请求，这样请求就不会进入Spring了。  方案三 -->
    <servlet-mapping>   
    	<servlet-name>default</servlet-name>  
    	<url-pattern>*.jpg</url-pattern>     
	</servlet-mapping>    
	<servlet-mapping>       
    	<servlet-name>default</servlet-name>    
    	<url-pattern>*.js</url-pattern>    
	</servlet-mapping>    
	<servlet-mapping>        
    	<servlet-name>default</servlet-name>       
    	<url-pattern>*.css</url-pattern>      
	</servlet-mapping>


	补充说明：多个HandlerMapping的执行顺序问题(优先执行order值较小的)：
	DefaultAnnotationHandlerMapping的order属性值是：0
	<mvc:resources/ >自动注册的SimpleUrlHandlerMapping的order属性值是：2147483646
	<mvc:default-servlet-handler/>自动注册的SimpleUrlHandlerMapping的order属性值是： 2147483647


	JUnit单元测试：JUnitActionBase类是所有JUnit的测试类的父类

	转发与重定向：redirect/forward:url	

	spring容器放在ServletContext中的key是org.springframework.web.servlet.FrameworkServlet.CONTEXT.springMVC。注意后面的springMVC，是你的servlet-name配置的值，注意适时修改。

	<!-- 用于持有ApplicationContext,可以使用SpringContextHolder.getBean('xxxx')的静态方法得到spring bean对象 -->
	<bean class="com.xxxxx.SpringContextHolder" lazy-init="false" />  














            Elasticsearch在curl中的用法：
查看全部索引：
curl -XGET http://10.86.41.155:9200/_cat/indices?v

curl -XGET http://10.86.41.155:9200/_count?pretty

curl -X<VERB> '<PROTOCOL>://<HOST>:<PORT>/<PATH>?<QUERY_STRING>' -d '<BODY>'

在 Elasticsearch 中文档是 不可改变 的，不能修改它们。 相反，如果想要更新现有的文档，需要 重建索引 或者进行替换.

脚本可以在 update API中用来改变 _source 的字段内容， 它在更新脚本中称为 ctx._source
POST /website/blog/1/_update
{
   "script" : "ctx._source.views+=1"
}

{ action: { metadata }}\n
{ request body        }\n
{ action: { metadata }}\n
{ request body        }\n
...(bulk批量操作API)
每行一定要以换行符(\n)结尾， 包括最后一行.
action:create,index,update,delete.

curl -i -XPOST 'http://10.86.41.155:9200/website/blog/1/_update?pretty' -d '
{
   "script" : "ctx._source.tags+=new_tag",
   "param" : {
      "new_tag" : "search"
   }
}'
提示new_tag未定义？？？




curl -i -XGET 'http://10.86.41.155:9200/gb?pretty' -d '
{
    "query" : {
        "match_all" : {
        }
    },
    "sort": { "_id": { "order": "desc" }}
}'

curl -XGET http://10.86.41.155:9200/hot/_analyze?pretty -d '
{
   "analyzer":"ik_smart",
   "text":"张其张李"
}'