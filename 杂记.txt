主机名	l-kola[1-8].f.dev.cn0
主机名	l-flight[1-8].wap.dev.cn0
KEY PASSPHRASE	>ku7:6zi?q=,?>0

l-kola2.f.dev.cn0

jdk 1.7  java开发/运行环境
maven  java 依赖管理 编译等
idea  java ide
git  代码仓库
SecureCRT   window系统登陆开发机

qtalk  公司内部通讯
邮箱   公司内部通讯
开发机权限  http://ops.corp.qunar.com/ops/account/  l-flight[1-8].wap.dev.cn0 l-kola[1-8].f.dev.cn0  sudo权限
gitlab   http://gitlab.corp.qunar.com/



git clone http://gitlab.corp.qunar.com/flightuser/incarnation.git
git branch -r
git checkout 20170622_init
git status
git checkout origin/master




git clone [url]
会默认创建一个远程仓库origin
git add
git status
git diff
git commit
git branch
git branch -D   删除本地分支
git log

git checkout -b 123 origin/master
新建的123与origin/master默认就有关联(--setupstream)!

git push  origin  :123
可以用于删除远程仓库origin的分支123

git push origin 123 --set-upstream
设置本地与远程仓库中分支的关联

git fetch origin
git reset --hard origin/master
丢弃本地所有改动与提交

git branch -vv（两个v），就能够看到本地分支跟踪的远程分支。

git branch --set-upstream master origin/next


mvn compile	编译源码
mvn test	执行test
mvn test-compile	编译测试代码，test可执行
mvn package	项目打包
mvn install	把project安装到本地的repository中，可作为本地其他项目的依赖
mvn site	为你的project创建一个站点
mvn clean	清除target目录下的所有文件
mvn eclipse:eclipse	为project生成eclipse的工程文件和classpath文件
mvn idea:idea	生成idea项目

mvn archetype:generate	创建mvn项目 
mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app	创建mvn项目
mvn jetty:run            运行项目于jetty上 
mvn -Dwtpversion=1.0 eclipse:eclipse        生成Wtp插件的Web项目 
mvn -Dwtpversion=1.0 eclipse:clean          清除Eclipse项目的配置信息(Web项目) 

组合使用goal命令，如只打包不测试：mvn -Dtest package
只打jar包：mvn jar:jar
只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile
清除eclipse的一些系统设置：mvn eclipse:clean

maven内置三种生命周期：default, clean 和 site。

default生命周期：
validate：validate the project is correct and all necessary information is available.
initialize：initialize build state, e.g. set properties or create directories.
generate-sources：generate any source code for inclusion in compilation.
process-sources：process the source code, for example to filter any values.
generate-resources：generate resources for inclusion in the package.
process-resources：copy and process the resources into the destination directory, ready for packaging.
compile：compile the source code of the project.
process-classes：post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.
generate-test-sources：generate any test source code for inclusion in compilation.
process-test-sources：process the test source code, for example to filter any values.
generate-test-resources：create resources for testing.
process-test-resources：copy and process the resources into the test destination directory.
test-compile：compile the test source code into the test destination directory
process-test-classes：post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above.
test：run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.
prepare-package：perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above)
package：take the compiled code and package it in its distributable format, such as a JAR.
pre-integration-test：perform actions required before integration tests are executed. This may involve things such as setting up the required environment.
integration-test：process and deploy the package if necessary into an environment where integration tests can be run.
post-integration-test：perform actions required after integration tests have been executed. This may including cleaning up the environment.
verify：run any checks to verify the package is valid and meets quality criteria.
install：install the package into the local repository, for use as a dependency in other projects locally.
deploy：done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.





Tomcat服务器的启动是基于一个server.xml文件的，Tomcat启动的时候首先会启动一个Server，Server里面就会启动Service，Service里面就会启动多个"Connector(连接器)"，每一个连接器都在等待客户机的连接，当有用户使用浏览器去访问服务器上面的web资源时，首先是连接到Connector(连接器)，Connector(连接器)是不处理用户的请求的，而是将用户的请求交给一个Engine(引擎)去处理，Engine(引擎)接收到请求后就会解析用户想要访问的Host，然后将请求交给相应的Host，Host收到请求后就会解析出用户想要访问这个Host下面的哪一个Web应用,一个web应用对应一个Context。



			Spring
控制反转，我们可以把它看作是一个概念。而依赖注入(Dependency Injection)是控制反转的一种实现方法。James Shore给出了依赖注入的定义：依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。
setter注入(setter injection)和构造器注入(constructor injection)。


泛型注入？


Spring IoC容器：
BeanFactory（资源缺乏的移动设备时）和ApplicationContext（较高级目前常用,BeanFactory的派生类）
两个接口各自的实现类：
BeanFactory：XmlBeanFactory
ApplicationContext：FileSystemXmlApplicationContext，ClassPathXmlApplicationContext，WebXmlApplicationContext

xml配置文件基础内容：
<bean id="helloWorld" class="com.spring.HelloWorld">
        <property name="message" value="Hello World!"/>
</bean>

Bean的作用域：（scope=）
singleton，prototype，request，session，globalSession

一般说来，有状态的 bean 使用 prototype 作用域和没有状态的 bean 使用 singleton 作用域。

Bean后置处理器：BeanPostProcessor
实现该接口，包含两个方法，分别于实例化前后被回调。


依赖注入的一个实例：
从 TextEditor 中删除了全面控制，并且把它保存到其他地方（即 XML 配置文件），且依赖关系（即 SpellChecker 类）通过类构造函数被注入到 TextEditor 类中。因此，控制流通过依赖注入（DI）已经“反转”，因为你已经有效地委托依赖关系到一些外部系统。



@RequestMapping(value = "/student", method = RequestMethod.GET)
   public ModelAndView student() {
      return new ModelAndView("student", "command", new Student());
   }
第一个 service 方法 student()，我们已经在名称为 “command” 的 ModelAndView 对象中传递一个空的 Student 对象，因为 spring 框架需要一个名称的 “command” 的对象，如果你在 JSP 文件中使用 <form:form> 标签。所以，当 student() 方法被调用时，它返回 student.jsp 视图。







			Spring注解
@Autowired，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。
@Autowired
@Qualifier("personDaoBean") 存在多个实例配合使用（指定注入Bean的名称）

@Resource的装配顺序：
(1)、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配
(2)、指定了name或者type则根据指定的类型去匹配bean
(3)、指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错

然后，区分一下@Autowired和@Resource两个注解的区别：
(1)、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配
(2)、@Autowired是Spring的注解，@Resource是J2EE的注解，Spring属于第三方的，J2EE是Java自己的东西，因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。

@Service注解对应的是业务层Bean，其实做了两件事情：
(1)、声明Zoo.java是一个bean，这点很重要，因为Zoo.java是一个bean，其他的类才可以使用@Autowired将Zoo作为一个成员变量自动注入。
(2)、Zoo.java在bean中的id是"zoo"，即类名且首字母小写。

@Component是所有受Spring 管理组件的通用形式，@Component注解可以放在类的头上，@Component不推荐使用。

@Controller对应控制层(表现层)的Bean，也就是Action。如果@Controller不指定其value【@Controller】，则默认的bean名字为这个类的类名首字母小写，如果指定value【@Controller(value="UserAction")】或者【@Controller("UserAction")】，则使用value作为bean的名字。

可以利用容器的scope="prototype"来保证每一个请求有一个单独的Action来处理，避免struts中Action的线程安全问题。spring 默认scope 是单例模式(scope="singleton")，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2 是要求每次次访问都对应不同的Action，scope="prototype" 可以保证当有请求的时候都创建一个Action对象。

@Repository对应数据访问层Bean，即DAO。

使用注解之前要开启自动扫描功能
<context:component-scan base-package="cn.test"/> 

@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。
@Lazy(true) 表示延迟初始化
@Scope用于指定scope作用域的（用在类上）
@PostConstruct用于指定初始化方法（用在方法上）
@PreDestory用于指定销毁方法（用在方法上）
@DependsOn：定义Bean初始化及销毁时的顺序
@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常
@Async异步方法调用








        SpringMVC注解
@RequestMapping(value="/content",method="RequestMethod.GET",params="action=del",headers="Accept=application/json",consumes="application/json",produces="application/json")
属性params要求请求的URL中参数必须包含指定内容
属性headers要求请求头中必须包含指定参数
属性consumes指定处理请求的提交内容类型(Content-Type)
属性produces指定返回的内容类型(Accept)

@RequestParam用于将请求参数区数据映射到功能处理方法的参数上。
三个属性：value,required,defaultValue
public String requestparam4(@RequestParam(value="username",required=false) String username)

@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。
@RequestMapping(value="/users/{userId}/topics/{topicId}")
public String test(@PathVariable(value="userId") int userId, @PathVariable(value="topicId") int topicId) 

@ModelAttribute可以应用在方法参数上或方法上。他的作用主要是当注解在方法参数上时会将注解的参数对象添加到Model中；当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，用于填充model属性，实际上控制器中的@ModelAttribute方法是在同一控制器中的所有@RequestMapping方法被调用之前调用的。
两种类型的@ModelAttribute方法。一种是：只加入一个属性，用方法的返回类型隐含表示(属性名称默认为返回类型首字母小写，亦可通过@ModelAttribute的value属性自定义)。另一种是：方法接受一个Model类型的参数，这个model可以加入任意多个model属性。
@Controller
@RequestMapping(value="/test")
public class TestController {
    @ModelAttribute//1
    public void populateModel(@RequestParam String abc, Model model) {
        model.addAttribute("attributeName", abc);
    }
    
    @RequestMapping(value = "/helloWorld")
    public String helloWorld() {
       return "test/helloWorld";
    }
}

@ModelAttribute//2
public User getUserInfo(String id){
    if(id!=null && !id.equals("")){
        return userService.getUserInfo(id);
    }
    return null;
}

@ModelAttribute和@RequestMapping可同时注释一个方法，这时这个方法的返回值并不是表示一个视图名称，而是model属性的值，视图名称由RequestToViewNameTranslator根据请求"/helloWorld"转换为helloWorld。


当@ModelAttribute注解用于方法参数时，它有了双重功能，即“存/取”。首先，它从模型中取出数据并赋予对应的参数，如果模型中尚不存在，则实例化一个，并存放于模型中；其次，一旦模型中已存在此数据对象，接下来一个很重要的步骤便是将请求参数或提交的表单绑定到此对象上（请求参数名映射对象属性名），这是Spring MVC提供的一个非常便利的机制--数据绑定。



类定义处标注@SessionAttributes：
可以使用两个属性types和value来指定要session化的ModelMap属性。
ModelMap中的属性默认的作用域是request级别。
@SessionAttributes("currUser")
将ModelMap中属性名为currUser的属性放到Session属性列表中，以便这个属性可以跨请求访问，在controller内部共享 model 属性。
@SessionAttributes需要清除时，使用SessionStatus.setComplete();来清除。



@Responsebody表示该方法的返回结果直接写入HTTP response body中。一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@Responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。
@RequestBody将HTTP请求正文插入方法中,使用适合的HttpMessageConverter将请求体写入某个对象。

@RequestBody 将HTTP请求正文转换为适合的HttpMessageConverter对象。
@ResponseBody 将内容或对象作为 HTTP 响应正文返回，并调用适合HttpMessageConverter的Adapter转换对象，写入输出流。

@RequestBody作用： 
 i) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；
 ii) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。
使用时机：
A) GET、POST方式提时， 根据request header Content-Type的值来判断:
application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）；
multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；
其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；
B) PUT方式提交时， 根据request header Content-Type的值来判断:
application/x-www-form-urlencoded， 必须；
multipart/form-data, 不能处理；
其他格式， 必须；
说明：request的body部分的数据编码格式由header部分的Content-Type指定；

@ResponseBody
作用：
	该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。
使用时机：
	返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；






            Elasticsearch在curl中的用法：
查看全部索引：
curl -XGET http://10.86.41.155:9200/_cat/indices?v

curl -XGET http://10.86.41.155:9200/_count?pretty

curl -X<VERB> '<PROTOCOL>://<HOST>:<PORT>/<PATH>?<QUERY_STRING>' -d '<BODY>'

在 Elasticsearch 中文档是 不可改变 的，不能修改它们。 相反，如果想要更新现有的文档，需要 重建索引 或者进行替换.

脚本可以在 update API中用来改变 _source 的字段内容， 它在更新脚本中称为 ctx._source
POST /website/blog/1/_update
{
   "script" : "ctx._source.views+=1"
}

{ action: { metadata }}\n
{ request body        }\n
{ action: { metadata }}\n
{ request body        }\n
...(bulk批量操作API)
每行一定要以换行符(\n)结尾， 包括最后一行.
action:create,index,update,delete.

curl -i -XPOST 'http://10.86.41.155:9200/website/blog/1/_update?pretty' -d '
{
   "script" : "ctx._source.tags+=new_tag",
   "param" : {
      "new_tag" : "search"
   }
}'
提示new_tag未定义？？？




curl -i -XGET 'http://10.86.41.155:9200/gb?pretty' -d '
{
    "query" : {
        "match_all" : {
        }
    },
    "sort": { "_id": { "order": "desc" }}
}'